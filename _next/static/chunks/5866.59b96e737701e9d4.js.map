{"version":3,"file":"static/chunks/5866.59b96e737701e9d4.js","mappings":"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","sources":["webpack://_N_E/./node_modules/@noble/ed25519/lib/esm/index.js"],"sourcesContent":["/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport * as nodeCrypto from 'crypto';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst CU_O = BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989');\nconst CURVE = Object.freeze({\n    a: BigInt(-1),\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    P: BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949'),\n    l: CU_O,\n    n: CU_O,\n    h: BigInt(8),\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n});\nexport { CURVE };\nconst POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\nconst SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\nconst SQRT_D = BigInt('6853475219497561581579357271197624642482790079785650197046958215289687604742');\nconst SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\nconst INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\nconst ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\nconst D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\nclass ExtendedPoint {\n    constructor(x, y, z, t) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.t = t;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('ExtendedPoint#fromAffine: expected Point');\n        }\n        if (p.equals(Point.ZERO))\n            return ExtendedPoint.ZERO;\n        return new ExtendedPoint(p.x, p.y, _1n, mod(p.x * p.y));\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return this.toAffineBatch(points).map(this.fromAffine);\n    }\n    equals(other) {\n        assertExtPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const X1Z2 = mod(X1 * Z2);\n        const X2Z1 = mod(X2 * Z1);\n        const Y1Z2 = mod(Y1 * Z2);\n        const Y2Z1 = mod(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    negate() {\n        return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { a } = CURVE;\n        const A = mod(X1 * X1);\n        const B = mod(Y1 * Y1);\n        const C = mod(_2n * mod(Z1 * Z1));\n        const D = mod(a * A);\n        const x1y1 = X1 + Y1;\n        const E = mod(mod(x1y1 * x1y1) - A - B);\n        const G = D + B;\n        const F = G - C;\n        const H = D - B;\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    add(other) {\n        assertExtPoint(other);\n        const { x: X1, y: Y1, z: Z1, t: T1 } = this;\n        const { x: X2, y: Y2, z: Z2, t: T2 } = other;\n        const A = mod((Y1 - X1) * (Y2 + X2));\n        const B = mod((Y1 + X1) * (Y2 - X2));\n        const F = mod(B - A);\n        if (F === _0n)\n            return this.double();\n        const C = mod(Z1 * _2n * T2);\n        const D = mod(T1 * _2n * Z2);\n        const E = D + C;\n        const G = B + A;\n        const H = D - C;\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    precomputeWindow(W) {\n        const windows = 1 + 256 / W;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(ExtendedPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = ExtendedPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = ExtendedPoint.ZERO;\n        let f = ExtendedPoint.ZERO;\n        const windows = 1 + 256 / W;\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            if (wbits === 0) {\n                let pr = precomputes[offset];\n                if (window % 2)\n                    pr = pr.negate();\n                f = f.add(pr);\n            }\n            else {\n                let cached = precomputes[offset + Math.abs(wbits) - 1];\n                if (wbits < 0)\n                    cached = cached.negate();\n                p = p.add(cached);\n            }\n        }\n        return ExtendedPoint.normalizeZ([p, f])[0];\n    }\n    multiply(scalar, affinePoint) {\n        return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);\n    }\n    multiplyUnsafe(scalar) {\n        let n = normalizeScalar(scalar, CURVE.l, false);\n        const G = ExtendedPoint.BASE;\n        const P0 = ExtendedPoint.ZERO;\n        if (n === _0n)\n            return P0;\n        if (this.equals(P0) || n === _1n)\n            return this;\n        if (this.equals(G))\n            return this.wNAF(n);\n        let p = P0;\n        let d = this;\n        while (n > _0n) {\n            if (n & _1n)\n                p = p.add(d);\n            d = d.double();\n            n >>= _1n;\n        }\n        return p;\n    }\n    isSmallOrder() {\n        return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n    }\n    isTorsionFree() {\n        return this.multiplyUnsafe(CURVE.l).equals(ExtendedPoint.ZERO);\n    }\n    toAffine(invZ = invert(this.z)) {\n        const { x, y, z } = this;\n        const ax = mod(x * invZ);\n        const ay = mod(y * invZ);\n        const zz = mod(z * invZ);\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n    fromRistrettoBytes() {\n        legacyRist();\n    }\n    toRistrettoBytes() {\n        legacyRist();\n    }\n    fromRistrettoHash() {\n        legacyRist();\n    }\n}\nExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod(CURVE.Gx * CURVE.Gy));\nExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);\nfunction assertExtPoint(other) {\n    if (!(other instanceof ExtendedPoint))\n        throw new TypeError('ExtendedPoint expected');\n}\nfunction assertRstPoint(other) {\n    if (!(other instanceof RistrettoPoint))\n        throw new TypeError('RistrettoPoint expected');\n}\nfunction legacyRist() {\n    throw new Error('Legacy method: switch to RistrettoPoint');\n}\nclass RistrettoPoint {\n    constructor(ep) {\n        this.ep = ep;\n    }\n    static calcElligatorRistrettoMap(r0) {\n        const { d } = CURVE;\n        const r = mod(SQRT_M1 * r0 * r0);\n        const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);\n        let c = BigInt(-1);\n        const D = mod((c - d * r) * mod(r + d));\n        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);\n        let s_ = mod(s * r0);\n        if (!edIsNegative(s_))\n            s_ = mod(-s_);\n        if (!Ns_D_is_sq)\n            s = s_;\n        if (!Ns_D_is_sq)\n            c = r;\n        const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);\n        const s2 = s * s;\n        const W0 = mod((s + s) * D);\n        const W1 = mod(Nt * SQRT_AD_MINUS_ONE);\n        const W2 = mod(_1n - s2);\n        const W3 = mod(_1n + s2);\n        return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n    }\n    static hashToCurve(hex) {\n        hex = ensureBytes(hex, 64);\n        const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n        const R1 = this.calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n        const R2 = this.calcElligatorRistrettoMap(r2);\n        return new RistrettoPoint(R1.add(R2));\n    }\n    static fromHex(hex) {\n        hex = ensureBytes(hex, 32);\n        const { a, d } = CURVE;\n        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n        const s = bytes255ToNumberLE(hex);\n        if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s))\n            throw new Error(emsg);\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2);\n        const u2 = mod(_1n - a * s2);\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2);\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2));\n        const Dx = mod(I * u2);\n        const Dy = mod(I * Dx * v);\n        let x = mod((s + s) * Dx);\n        if (edIsNegative(x))\n            x = mod(-x);\n        const y = mod(u1 * Dy);\n        const t = mod(x * y);\n        if (!isValid || edIsNegative(t) || y === _0n)\n            throw new Error(emsg);\n        return new RistrettoPoint(new ExtendedPoint(x, y, _1n, t));\n    }\n    toRawBytes() {\n        let { x, y, z, t } = this.ep;\n        const u1 = mod(mod(z + y) * mod(z - y));\n        const u2 = mod(x * y);\n        const u2sq = mod(u2 * u2);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));\n        const D1 = mod(invsqrt * u1);\n        const D2 = mod(invsqrt * u2);\n        const zInv = mod(D1 * D2 * t);\n        let D;\n        if (edIsNegative(t * zInv)) {\n            let _x = mod(y * SQRT_M1);\n            let _y = mod(x * SQRT_M1);\n            x = _x;\n            y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        }\n        else {\n            D = D2;\n        }\n        if (edIsNegative(x * zInv))\n            y = mod(-y);\n        let s = mod((z - y) * D);\n        if (edIsNegative(s))\n            s = mod(-s);\n        return numberTo32BytesLE(s);\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    equals(other) {\n        assertRstPoint(other);\n        const a = this.ep;\n        const b = other.ep;\n        const one = mod(a.x * b.y) === mod(a.y * b.x);\n        const two = mod(a.y * b.y) === mod(a.x * b.x);\n        return one || two;\n    }\n    add(other) {\n        assertRstPoint(other);\n        return new RistrettoPoint(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        assertRstPoint(other);\n        return new RistrettoPoint(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return new RistrettoPoint(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));\n    }\n}\nRistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);\nRistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);\nconst pointPrecomputes = new WeakMap();\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    static fromHex(hex, strict = true) {\n        const { d, P } = CURVE;\n        hex = ensureBytes(hex, 32);\n        const normed = hex.slice();\n        normed[31] = hex[31] & ~0x80;\n        const y = bytesToNumberLE(normed);\n        if (strict && y >= P)\n            throw new Error('Expected 0 < hex < P');\n        if (!strict && y >= POW_2_256)\n            throw new Error('Expected 0 < hex < 2**256');\n        const y2 = mod(y * y);\n        const u = mod(y2 - _1n);\n        const v = mod(d * y2 + _1n);\n        let { isValid, value: x } = uvRatio(u, v);\n        if (!isValid)\n            throw new Error('Point.fromHex: invalid y coordinate');\n        const isXOdd = (x & _1n) === _1n;\n        const isLastByteOdd = (hex[31] & 0x80) !== 0;\n        if (isLastByteOdd !== isXOdd) {\n            x = mod(-x);\n        }\n        return new Point(x, y);\n    }\n    static async fromPrivateKey(privateKey) {\n        return (await getExtendedPublicKey(privateKey)).point;\n    }\n    toRawBytes() {\n        const bytes = numberTo32BytesLE(this.y);\n        bytes[31] |= this.x & _1n ? 0x80 : 0;\n        return bytes;\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toX25519() {\n        const { y } = this;\n        const u = mod((_1n + y) * invert(_1n - y));\n        return numberTo32BytesLE(u);\n    }\n    isTorsionFree() {\n        return ExtendedPoint.fromAffine(this).isTorsionFree();\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(mod(-this.x), this.y);\n    }\n    add(other) {\n        return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _1n);\nclass Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex, 64);\n        const r = Point.fromHex(bytes.slice(0, 32), false);\n        const s = bytesToNumberLE(bytes.slice(32, 64));\n        return new Signature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!(r instanceof Point))\n            throw new Error('Expected Point instance');\n        normalizeScalar(s, CURVE.l, false);\n        return this;\n    }\n    toRawBytes() {\n        const u8 = new Uint8Array(64);\n        u8.set(this.r.toRawBytes());\n        u8.set(numberTo32BytesLE(this.s), 32);\n        return u8;\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n}\nexport { ExtendedPoint, RistrettoPoint, Point, Signature };\nfunction concatBytes(...arrays) {\n    if (!arrays.every((a) => a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array list');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction numberTo32BytesBE(num) {\n    const length = 32;\n    const hex = num.toString(16).padStart(length * 2, '0');\n    return hexToBytes(hex);\n}\nfunction numberTo32BytesLE(num) {\n    return numberTo32BytesBE(num).reverse();\n}\nfunction edIsNegative(num) {\n    return (mod(num) & _1n) === _1n;\n}\nfunction bytesToNumberLE(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    return BigInt('0x' + bytesToHex(Uint8Array.from(uint8a).reverse()));\n}\nconst MAX_255B = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\nfunction bytes255ToNumberLE(bytes) {\n    return mod(bytesToNumberLE(bytes) & MAX_255B);\n}\nfunction mod(a, b = CURVE.P) {\n    const res = a % b;\n    return res >= _0n ? res : b + res;\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const tmp = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        tmp[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        tmp[i] = mod(acc * tmp[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return tmp;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction pow_2_252_3(x) {\n    const { P } = CURVE;\n    const _5n = BigInt(5);\n    const _10n = BigInt(10);\n    const _20n = BigInt(20);\n    const _40n = BigInt(40);\n    const _80n = BigInt(80);\n    const x2 = (x * x) % P;\n    const b2 = (x2 * x) % P;\n    const b4 = (pow2(b2, _2n) * b2) % P;\n    const b5 = (pow2(b4, _1n) * x) % P;\n    const b10 = (pow2(b5, _5n) * b5) % P;\n    const b20 = (pow2(b10, _10n) * b10) % P;\n    const b40 = (pow2(b20, _20n) * b20) % P;\n    const b80 = (pow2(b40, _40n) * b40) % P;\n    const b160 = (pow2(b80, _80n) * b80) % P;\n    const b240 = (pow2(b160, _80n) * b80) % P;\n    const b250 = (pow2(b240, _10n) * b10) % P;\n    const pow_p_5_8 = (pow2(b250, _2n) * x) % P;\n    return { pow_p_5_8, b2 };\n}\nfunction uvRatio(u, v) {\n    const v3 = mod(v * v * v);\n    const v7 = mod(v3 * v3 * v);\n    const pow = pow_2_252_3(u * v7).pow_p_5_8;\n    let x = mod(u * v3 * pow);\n    const vx2 = mod(v * x * x);\n    const root1 = x;\n    const root2 = mod(x * SQRT_M1);\n    const useRoot1 = vx2 === u;\n    const useRoot2 = vx2 === mod(-u);\n    const noRoot = vx2 === mod(-u * SQRT_M1);\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2;\n    if (edIsNegative(x))\n        x = mod(-x);\n    return { isValid: useRoot1 || useRoot2, value: x };\n}\nfunction invertSqrt(number) {\n    return uvRatio(_1n, number);\n}\nfunction modlLE(hash) {\n    return mod(bytesToNumberLE(hash), CURVE.l);\n}\nfunction equalBytes(b1, b2) {\n    if (b1.length !== b2.length) {\n        return false;\n    }\n    for (let i = 0; i < b1.length; i++) {\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction ensureBytes(hex, expectedLength) {\n    const bytes = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n    if (typeof expectedLength === 'number' && bytes.length !== expectedLength)\n        throw new Error(`Expected ${expectedLength} bytes`);\n    return bytes;\n}\nfunction normalizeScalar(num, max, strict = true) {\n    if (!max)\n        throw new TypeError('Specify max value');\n    if (typeof num === 'number' && Number.isSafeInteger(num))\n        num = BigInt(num);\n    if (typeof num === 'bigint' && num < max) {\n        if (strict) {\n            if (_0n < num)\n                return num;\n        }\n        else {\n            if (_0n <= num)\n                return num;\n        }\n    }\n    throw new TypeError('Expected valid scalar: 0 < scalar < max');\n}\nfunction adjustBytes25519(bytes) {\n    bytes[0] &= 248;\n    bytes[31] &= 127;\n    bytes[31] |= 64;\n    return bytes;\n}\nfunction decodeScalar25519(n) {\n    return bytesToNumberLE(adjustBytes25519(ensureBytes(n, 32)));\n}\nfunction checkPrivateKey(key) {\n    key =\n        typeof key === 'bigint' || typeof key === 'number'\n            ? numberTo32BytesBE(normalizeScalar(key, POW_2_256))\n            : ensureBytes(key);\n    if (key.length !== 32)\n        throw new Error(`Expected 32 bytes`);\n    return key;\n}\nfunction getKeyFromHash(hashed) {\n    const head = adjustBytes25519(hashed.slice(0, 32));\n    const prefix = hashed.slice(32, 64);\n    const scalar = modlLE(head);\n    const point = Point.BASE.multiply(scalar);\n    const pointBytes = point.toRawBytes();\n    return { head, prefix, scalar, point, pointBytes };\n}\nlet _sha512Sync;\nfunction sha512s(...m) {\n    if (typeof _sha512Sync !== 'function')\n        throw new Error('utils.sha512Sync must be set to use sync methods');\n    return _sha512Sync(...m);\n}\nasync function getExtendedPublicKey(key) {\n    return getKeyFromHash(await utils.sha512(checkPrivateKey(key)));\n}\nfunction getExtendedPublicKeySync(key) {\n    return getKeyFromHash(sha512s(checkPrivateKey(key)));\n}\nexport async function getPublicKey(privateKey) {\n    return (await getExtendedPublicKey(privateKey)).pointBytes;\n}\nfunction getPublicKeySync(privateKey) {\n    return getExtendedPublicKeySync(privateKey).pointBytes;\n}\nexport async function sign(message, privateKey) {\n    message = ensureBytes(message);\n    const { prefix, scalar, pointBytes } = await getExtendedPublicKey(privateKey);\n    const r = modlLE(await utils.sha512(prefix, message));\n    const R = Point.BASE.multiply(r);\n    const k = modlLE(await utils.sha512(R.toRawBytes(), pointBytes, message));\n    const s = mod(r + k * scalar, CURVE.l);\n    return new Signature(R, s).toRawBytes();\n}\nfunction signSync(message, privateKey) {\n    message = ensureBytes(message);\n    const { prefix, scalar, pointBytes } = getExtendedPublicKeySync(privateKey);\n    const r = modlLE(sha512s(prefix, message));\n    const R = Point.BASE.multiply(r);\n    const k = modlLE(sha512s(R.toRawBytes(), pointBytes, message));\n    const s = mod(r + k * scalar, CURVE.l);\n    return new Signature(R, s).toRawBytes();\n}\nfunction prepareVerification(sig, message, publicKey) {\n    message = ensureBytes(message);\n    if (!(publicKey instanceof Point))\n        publicKey = Point.fromHex(publicKey, false);\n    const { r, s } = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig);\n    const SB = ExtendedPoint.BASE.multiplyUnsafe(s);\n    return { r, s, SB, pub: publicKey, msg: message };\n}\nfunction finishVerification(publicKey, r, SB, hashed) {\n    const k = modlLE(hashed);\n    const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);\n    const RkA = ExtendedPoint.fromAffine(r).add(kA);\n    return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n}\nexport async function verify(sig, message, publicKey) {\n    const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey);\n    const hashed = await utils.sha512(r.toRawBytes(), pub.toRawBytes(), msg);\n    return finishVerification(pub, r, SB, hashed);\n}\nfunction verifySync(sig, message, publicKey) {\n    const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey);\n    const hashed = sha512s(r.toRawBytes(), pub.toRawBytes(), msg);\n    return finishVerification(pub, r, SB, hashed);\n}\nexport const sync = {\n    getExtendedPublicKey: getExtendedPublicKeySync,\n    getPublicKey: getPublicKeySync,\n    sign: signSync,\n    verify: verifySync,\n};\nexport async function getSharedSecret(privateKey, publicKey) {\n    const { head } = await getExtendedPublicKey(privateKey);\n    const u = Point.fromHex(publicKey).toX25519();\n    return curve25519.scalarMult(head, u);\n}\nPoint.BASE._setWindowSize(8);\nfunction cswap(swap, x_2, x_3) {\n    const dummy = mod(swap * (x_2 - x_3));\n    x_2 = mod(x_2 - dummy);\n    x_3 = mod(x_3 + dummy);\n    return [x_2, x_3];\n}\nfunction montgomeryLadder(pointU, scalar) {\n    const { P } = CURVE;\n    const u = normalizeScalar(pointU, P);\n    const k = normalizeScalar(scalar, P);\n    const a24 = BigInt(121665);\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    let sw;\n    for (let t = BigInt(255 - 1); t >= _0n; t--) {\n        const k_t = (k >> t) & _1n;\n        swap ^= k_t;\n        sw = cswap(swap, x_2, x_3);\n        x_2 = sw[0];\n        x_3 = sw[1];\n        sw = cswap(swap, z_2, z_3);\n        z_2 = sw[0];\n        z_3 = sw[1];\n        swap = k_t;\n        const A = x_2 + z_2;\n        const AA = mod(A * A);\n        const B = x_2 - z_2;\n        const BB = mod(B * B);\n        const E = AA - BB;\n        const C = x_3 + z_3;\n        const D = x_3 - z_3;\n        const DA = mod(D * A);\n        const CB = mod(C * B);\n        const dacb = DA + CB;\n        const da_cb = DA - CB;\n        x_3 = mod(dacb * dacb);\n        z_3 = mod(x_1 * mod(da_cb * da_cb));\n        x_2 = mod(AA * BB);\n        z_2 = mod(E * (AA + mod(a24 * E)));\n    }\n    sw = cswap(swap, x_2, x_3);\n    x_2 = sw[0];\n    x_3 = sw[1];\n    sw = cswap(swap, z_2, z_3);\n    z_2 = sw[0];\n    z_3 = sw[1];\n    const { pow_p_5_8, b2 } = pow_2_252_3(z_2);\n    const xp2 = mod(pow2(pow_p_5_8, BigInt(3)) * b2);\n    return mod(x_2 * xp2);\n}\nfunction encodeUCoordinate(u) {\n    return numberTo32BytesLE(mod(u, CURVE.P));\n}\nfunction decodeUCoordinate(uEnc) {\n    const u = ensureBytes(uEnc, 32);\n    u[31] &= 127;\n    return bytesToNumberLE(u);\n}\nexport const curve25519 = {\n    BASE_POINT_U: '0900000000000000000000000000000000000000000000000000000000000000',\n    scalarMult(privateKey, publicKey) {\n        const u = decodeUCoordinate(publicKey);\n        const p = decodeScalar25519(privateKey);\n        const pu = montgomeryLadder(u, p);\n        if (pu === _0n)\n            throw new Error('Invalid private or public key received');\n        return encodeUCoordinate(pu);\n    },\n    scalarMultBase(privateKey) {\n        return curve25519.scalarMult(privateKey, curve25519.BASE_POINT_U);\n    },\n};\nconst crypto = {\n    node: nodeCrypto,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nexport const utils = {\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    getExtendedPublicKey,\n    mod,\n    invert,\n    TORSION_SUBGROUP: [\n        '0100000000000000000000000000000000000000000000000000000000000000',\n        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n        '0000000000000000000000000000000000000000000000000000000000000080',\n        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n        'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n        '0000000000000000000000000000000000000000000000000000000000000000',\n        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n    ],\n    hashToPrivateScalar: (hash) => {\n        hash = ensureBytes(hash);\n        if (hash.length < 40 || hash.length > 1024)\n            throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\n        return mod(bytesToNumberLE(hash), CURVE.l - _1n) + _1n;\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return new Uint8Array(randomBytes(bytesLength).buffer);\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => {\n        return utils.randomBytes(32);\n    },\n    sha512: async (...messages) => {\n        const message = concatBytes(...messages);\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-512', message.buffer);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            return Uint8Array.from(crypto.node.createHash('sha512').update(message).digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha512 function\");\n        }\n    },\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_2n);\n        return cached;\n    },\n    sha512Sync: undefined,\n};\nObject.defineProperties(utils, {\n    sha512Sync: {\n        configurable: false,\n        get() {\n            return _sha512Sync;\n        },\n        set(val) {\n            if (!_sha512Sync)\n                _sha512Sync = val;\n        },\n    },\n});\n"],"names":["_0n","BigInt","_1n","_2n","CU_O","CURVE","Object","freeze","a","d","P","l","n","h","Gx","Gy","POW_2_256","SQRT_M1","SQRT_AD_MINUS_ONE","INVSQRT_A_MINUS_D","ONE_MINUS_D_SQ","D_MINUS_ONE_SQ","ExtendedPoint","constructor","x","y","z","t","this","static","p","Point","TypeError","equals","ZERO","mod","points","toInv","nums","tmp","Array","length","inverted","invert","reduce","acc","num","i","reduceRight","invertBatch","map","toAffine","toAffineBatch","fromAffine","other","assertExtPoint","X1","Y1","Z1","X2","Y2","Z2","X1Z2","X2Z1","Y1Z2","Y2Z1","negate","double","A","B","C","D","x1y1","E","G","F","H","X3","Y3","T3","Z3","add","T1","T2","subtract","precomputeWindow","W","windows","base","window","push","wNAF","affinePoint","BASE","_WINDOW_SIZE","Error","precomputes","pointPrecomputes","get","normalizeZ","set","f","windowSize","mask","maxNumber","shiftBy","offset","wbits","Number","pr","cached","Math","abs","multiply","scalar","normalizeScalar","multiplyUnsafe","P0","isSmallOrder","isTorsionFree","invZ","ax","ay","fromRistrettoBytes","legacyRist","toRistrettoBytes","fromRistrettoHash","assertRstPoint","RistrettoPoint","ep","r0","r","Ns","c","isValid","Ns_D_is_sq","value","s","uvRatio","s_","edIsNegative","Nt","s2","W0","W1","W2","W3","hex","r1","bytes255ToNumberLE","ensureBytes","slice","R1","calcElligatorRistrettoMap","r2","R2","emsg","b1","b2","equalBytes","numberTo32BytesLE","u1","u2","u1_2","u2_2","v","I","invertSqrt","Dx","Dy","toRawBytes","u2sq","invsqrt","D1","D2","zInv","_x","_y","toHex","bytesToHex","toString","b","one","two","WeakMap","_setWindowSize","delete","strict","normed","bytesToNumberLE","y2","u","isXOdd","privateKey","getExtendedPublicKey","point","bytes","toX25519","Signature","assertValidity","fromHex","u8","Uint8Array","concatBytes","arrays","every","arr","result","pad","hexes","from","padStart","uint8a","hexToBytes","array","j","hexByte","byte","parseInt","isNaN","numberTo32BytesBE","reverse","MAX_255B","res","number","modulo","q","m","pow2","power","pow_2_252_3","_5n","_10n","_20n","_40n","_80n","b4","b5","b10","b20","b40","b80","b160","b240","b250","pow_p_5_8","v3","v7","vx2","root1","root2","useRoot1","useRoot2","noRoot","modlLE","hash","expectedLength","max","isSafeInteger","adjustBytes25519","checkPrivateKey","key","getKeyFromHash","hashed","head","prefix","pointBytes","_sha512Sync","sha512s","async","utils","sha512","getExtendedPublicKeySync","getPublicKey","sign","message","R","prepareVerification","sig","publicKey","SB","pub","msg","finishVerification","k","kA","verify","sync","crypto","node","web","self","undefined","TORSION_SUBGROUP","hashToPrivateScalar","randomBytes","bytesLength","getRandomValues","buffer","randomPrivateKey","messages","subtle","digest","createHash","update","precompute","sha512Sync","defineProperties","configurable","val"],"sourceRoot":""}